module.exports = function(RED) {
    // function Compareeq(a, b) {
    //     return (a == b) ? true : false;
    // }
    const getDateFromTimeString = str => new Date(null, null, null, ...str.split(':').map(t => parseInt(t)))
    function Comparegt(a, b) {
        return (a > b) ? true : false;
    }
    // function Comparegte(a, b) {
    //     return (a >= b) ? true : false;
    // }
    // function Comparelt(a, b) {
    //     return (a < b) ? true : false;
    // }
    function Comparelte(a, b) {
        return (a <= b) ? true : false;
    }

    function CheckNode(config) {
        RED.nodes.createNode(this,config);
        this.start = config.start;
        this.end = config.end;
        this.volume = config.volume;
        this.compare = config.compare;
        this.errorMsg = msg => {
            this.error(msg)
            this.status({ fill: 'red', shape: 'dot', text: msg })
            setTimeout(() => this.status({}), 10000)
          }
          
    this.validateDates = function (startDate, endDate) {
        if (startDate >= endDate) {
          this.errorMsg('Start time >= end time')
          return false
        }
        return true
      }
      if (!/^\d\d:\d\d:\d\d$/.test(this.start) || !/^\d\d:\d\d:\d\d$/.test(this.end)) {
        this.errorMsg('Malformed time')
        return false
      }
      this.startDate = getDateFromTimeString(this.start)
      this.endDate = getDateFromTimeString(this.end)
      this.validateDates(this.startDate, this.endDate)
        var node = this;

        // var timenow = new Date().getHours();
        
        node.on('input', function(msg) {
            if (!node.validateDates(node.startDate, node.endDate)) return
            const now = Date.now()
            const start = (new Date(now)).setHours(node.startDate.getHours(), node.startDate.getMinutes(), node.startDate.getSeconds(), 0)
            const end = (new Date(now)).setHours(node.endDate.getHours(), node.endDate.getMinutes(), node.endDate.getSeconds(), 0)
            var tmp = msg.payload[0].vs.volume;
            if (now >= start && now < end) {
                switch (node.compare) {
                    // case "eq" :
                    //     if(Compareeq(vl, node.volume)) {
                    //         msg.payload = "";
                    //         node.send(msg);
                    //     } else {
                    //         node.warn("Not equal");
                    //     }
                    //     break;
                    case "gt":
                        if(Comparegt(tmp, node.volume)) {
                            msg.payload = "Phát hiện âm thanh quá ngưỡng trong khoảng thời gian: " + this.start +" - " + this.end;
                            node.send(msg);
                        } 
                        else {
                            node.warn("Âm thanh điều khiển không vượt quá ngưỡng");
                        }
                        break;
                    // case "gte":
                    //     if(Comparegte(vl, node.volume)) {
                    //         msg.payload = true;
                    //         node.send(msg);
                    //     } else {
                    //         node.warn("Not greater than or equal");
                    //     }
                    //     break;
                    // case "lt":
                    //     if(Comparelt(vl, node.volume)) {
                    //         msg.payload = true;
                    //         node.send(msg);
                    //     } else {
                    //         node.warn("Not less than");
                    //     }
                    //     break;
                    case "lte":
                        if(Comparelte(tmp, node.volume)) {
                            msg.payload = "Phát hiện âm thanh dưới ngưỡng trong khoảng thời gian: " + this.start +" - " + this.end;
                            node.send(msg);
                        }
                         else {
                            node.warn("Âm thanh điều khiển không dưới ngưỡng");
                        }
                        break;
                }
            } else {
                node.warn("Thời gian hiện tại không nằm trong khoảng");
            }
        });
    }
    RED.nodes.registerType("anomaly volume",CheckNode);
}